<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced PumpFun Widget</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: transparent;
            height: 100vh;
            overflow: hidden;
        }

        /* Market Cap Display */
        .marketcap-widget {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid #00ff88;
            border-radius: 15px;
            padding: 15px 25px;
            text-align: center;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            z-index: 100;
        }

        .marketcap {
            color: #00ff88;
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 5px;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .marketcap-label {
            color: #ffffff;
            font-size: 12px;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Transaction Notification */
        .transaction-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, #ff6b6b, #ff8e53);
            border: 3px solid #fff;
            border-radius: 20px;
            padding: 30px 40px;
            text-align: center;
            color: white;
            box-shadow: 0 0 40px rgba(255, 107, 107, 0.6);
            z-index: 200;
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            max-width: 500px;
        }

        .transaction-notification.milestone {
            background: linear-gradient(135deg, #00ff88, #0066ff);
            box-shadow: 0 0 40px rgba(0, 255, 136, 0.6);
        }

        .transaction-notification.big-buy {
            background: linear-gradient(135deg, #ffd700, #ff6b35);
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.6);
        }

        .transaction-notification.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        .transaction-amount {
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }

        .transaction-text {
            font-size: 18px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .transaction-user {
            font-size: 14px;
            opacity: 0.9;
            margin-bottom: 15px;
            font-family: monospace;
            word-break: break-all;
        }

        .transaction-details {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 10px;
        }

        /* Roulette Wheel */
        .roulette-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            opacity: 0;
            z-index: 300;
            transition: all 0.8s ease;
        }

        .roulette-container.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        .roulette-wheel {
            width: 400px;
            height: 400px;
            border: 8px solid #fff;
            border-radius: 50%;
            position: relative;
            background: conic-gradient(
                from 0deg,
                #ff6b6b 0deg 72deg,
                #4ecdc4 72deg 144deg,
                #45b7d1 144deg 216deg,
                #f9ca24 216deg 288deg,
                #f0932b 288deg 360deg
            );
            box-shadow: 0 0 50px rgba(255, 255, 255, 0.3);
            transition: transform 4s cubic-bezier(0.23, 1, 0.320, 1);
        }

        .roulette-pointer {
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-top: 30px solid #fff;
            z-index: 10;
        }

        .roulette-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            background: #fff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: #333;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        }

        .task-segments {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .segment {
            position: absolute;
            width: 50%;
            height: 50%;
            transform-origin: 100% 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
            text-align: center;
            padding: 10px;
            box-sizing: border-box;
        }

        .segment:nth-child(1) { transform: rotate(0deg) skew(-18deg); }
        .segment:nth-child(2) { transform: rotate(72deg) skew(-18deg); }
        .segment:nth-child(3) { transform: rotate(144deg) skew(-18deg); }
        .segment:nth-child(4) { transform: rotate(216deg) skew(-18deg); }
        .segment:nth-child(5) { transform: rotate(288deg) skew(-18deg); }

        /* Task Result */
        .task-result {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 3px solid #fff;
            border-radius: 15px;
            padding: 20px 30px;
            color: white;
            text-align: center;
            opacity: 0;
            transition: all 0.6s ease;
            max-width: 400px;
        }

        .task-result.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .task-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .task-description {
            font-size: 16px;
            line-height: 1.4;
        }

        /* Status */
        .status {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 12px;
            z-index: 100;
        }

        .status.active {
            border-left: 4px solid #00ff88;
        }

        .status.error {
            border-left: 4px solid #ff4444;
        }

        .status.monitoring {
            border-left: 4px solid #ffd700;
        }

        /* Milestone Progress */
        .milestone-progress {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            min-width: 250px;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: #333;
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #0066ff);
            transition: width 0.5s ease;
        }

        /* Transaction Monitor Info */
        .transaction-monitor {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 11px;
            z-index: 100;
            max-width: 200px;
        }
    </style>
</head>
<body>
    <!-- Market Cap Widget -->
    <div class="marketcap-widget">
        <div class="marketcap" id="marketcap">Loading...</div>
        <div class="marketcap-label">Market Cap</div>
    </div>

    <!-- Transaction Notification -->
    <div class="transaction-notification" id="transactionNotification">
        <div class="transaction-amount" id="transactionAmount">$500</div>
        <div class="transaction-text" id="transactionText">BIG BUY DETECTED!</div>
        <div class="transaction-user" id="transactionUser">User: 7xKq...Mx9A</div>
        <div class="transaction-details" id="transactionDetails">5 SOL ‚Ä¢ Time for a challenge...</div>
    </div>

    <!-- Roulette Wheel -->
    <div class="roulette-container" id="rouletteContainer">
        <div class="roulette-pointer"></div>
        <div class="roulette-wheel" id="rouletteWheel">
            <div class="task-segments" id="taskSegments">
                <div class="segment">Loading...</div>
                <div class="segment">Tasks...</div>
                <div class="segment">Please</div>
                <div class="segment">Wait...</div>
                <div class="segment">...</div>
            </div>
            <div class="roulette-center">SPIN</div>
        </div>
    </div>

    <!-- Task Result -->
    <div class="task-result" id="taskResult">
        <div class="task-title" id="taskTitle">CHALLENGE SELECTED!</div>
        <div class="task-description" id="taskDescription">Your task will appear here...</div>
    </div>

    <!-- Status -->
    <div class="status active" id="status">
        üü¢ Monitoring transactions...
    </div>

    <!-- Milestone Progress -->
    <div class="milestone-progress" id="milestoneProgress">
        <div style="font-size: 12px; opacity: 0.8;">Next Milestone</div>
        <div style="font-weight: bold; margin: 5px 0;" id="milestoneText">$10,000</div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 0%;"></div>
        </div>
        <div style="font-size: 11px; opacity: 0.6;" id="progressText">$0 / $10,000</div>
    </div>

    <!-- Transaction Monitor -->
    <div class="transaction-monitor" id="transactionMonitor">
        <div>üîç Transaction Monitor</div>
        <div style="margin-top: 5px; opacity: 0.8;">
            <div>SOL Price: <span id="solPrice">$0</span></div>
            <div>Min Buy: <span id="minBuyUSD">$100</span></div>
            <div>Last Check: <span id="lastCheck">--:--</span></div>
        </div>
    </div>

    <script>
        // Default configuration
        let config = {
            tokenContract: 'FyB8VxxYAaVVchAgbB1kvjWdw26ovaD4ipwV1j8epump',
            buyThresholds: {
                minBuyUSD: 100, // –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –ø–æ–∫—É–ø–∫–∏ –≤ USD
                bigBuyUSD: 1000, // –ö—Ä—É–ø–Ω–∞—è –ø–æ–∫—É–ø–∫–∞ –≤ USD
                whaleBuyUSD: 10000 // –ü–æ–∫—É–ø–∫–∞ –∫–∏—Ç–∞ –≤ USD
            },
            marketCapMilestones: [
                { min: 0, max: 100000, step: 10000, description: "Early Stage" },
                { min: 100000, max: 500000, step: 50000, description: "Growth Stage" },
                { min: 500000, max: 1000000, step: 100000, description: "Advanced Stage" },
                { min: 1000000, max: 5000000, step: 100000, description: "Mature Stage" },
                { min: 5000000, max: 999999999, step: 500000, description: "Elite Stage" }
            ],
            monitoringSettings: {
                marketCapCheckInterval: 5000,
                transactionCheckInterval: 10000,
                enableTransactionMonitoring: true,
                enableMilestoneMonitoring: true
            },
            uiSettings: {
                notificationDuration: 3000,
                rouletteDuration: 4000,
                taskResultDuration: 5000,
                enableSounds: false
            }
        };

        let tasks = [
            "Do 10 pushups right now! üí™",
            "Drink a full glass of water üíß",
            "Say something positive about the project üöÄ",
            "Dance for 1 minute üï∫",
            "Tell the chat your best crypto joke üòÇ"
        ];

        let specialTasks = {
            milestone: [],
            bigBuy: [],
            whale: [],
            regular: []
        };

        // State
        let currentMarketCap = 0;
        let solPrice = 0;
        let nextMilestone = 10000;
        let isAnimating = false;
        let transactionMonitorActive = false;
        let lastTransactions = new Set(); // –î–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è

        // DOM Elements
        const marketCapElement = document.getElementById('marketcap');
        const transactionNotification = document.getElementById('transactionNotification');
        const rouletteContainer = document.getElementById('rouletteContainer');
        const rouletteWheel = document.getElementById('rouletteWheel');
        const taskResult = document.getElementById('taskResult');
        const statusElement = document.getElementById('status');
        const milestoneProgress = document.getElementById('milestoneProgress');
        const transactionMonitor = document.getElementById('transactionMonitor');

        // Initialize
        init();

        async function init() {
            console.log('üöÄ Advanced PumpFun Widget initialized');
            
            // Load configs first
            await loadConfig();
            await loadTasks();
            
            updateTaskSegments();
            await fetchSOLPrice();
            updateMonitorDisplay();
            startMonitoring();
            
            // Expose test functions to global scope
            window.testBuy = testBuy;
            window.testMilestone = testMilestone;
            window.testRoulette = testRoulette;
            window.testTransaction = testTransaction;
            
            console.log('Available test functions: testBuy(usdAmount), testMilestone(), testRoulette(), testTransaction()');
        }

        function updateTaskSegments() {
            const segments = document.getElementById('taskSegments');
            segments.innerHTML = '';
            
            for (let i = 0; i < 5; i++) {
                const segment = document.createElement('div');
                segment.className = 'segment';
                segment.textContent = tasks[i] || `Task ${i + 1}`;
                segments.appendChild(segment);
            }
        }

        // –ü–æ–ª—É—á–µ–Ω–∏–µ —Ü–µ–Ω—ã SOL
        async function fetchSOLPrice() {
            try {
                const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd');
                const data = await response.json();
                if (data.solana && data.solana.usd) {
                    solPrice = data.solana.usd;
                    console.log(`SOL Price updated: $${solPrice}`);
                    return solPrice;
                }
            } catch (error) {
                console.error('Error fetching SOL price:', error);
                // Fallback —Ü–µ–Ω–∞
                solPrice = 150;
            }
            return solPrice;
        }

        // –ü–æ–ª—É—á–µ–Ω–∏–µ —Ü–µ–Ω—ã —Ç–æ–∫–µ–Ω–∞
        async function fetchTokenPrice() {
            try {
                const response = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${config.tokenContract}`);
                const data = await response.json();
                
                if (data.pairs && data.pairs.length > 0) {
                    const bestPair = data.pairs.reduce((best, current) => {
                        const bestLiq = parseFloat(best.liquidity?.usd || 0);
                        const currentLiq = parseFloat(current.liquidity?.usd || 0);
                        return currentLiq > bestLiq ? current : best;
                    });
                    
                    return {
                        priceUsd: parseFloat(bestPair.priceUsd || 0),
                        marketCap: parseFloat(bestPair.marketCap || bestPair.fdv || 0)
                    };
                }
            } catch (error) {
                console.error('Error fetching token price:', error);
            }
            return { priceUsd: 0, marketCap: 0 };
        }

        async function fetchMarketCap() {
            const tokenData = await fetchTokenPrice();
            return tokenData.marketCap;
        }

        // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è —Ç–æ–∫–µ–Ω–æ–≤ –≤ USD
        function convertToUSD(amount, token) {
            if (token === 'SOL' || token === 'sol') {
                return amount * solPrice;
            }
            // –î–ª—è –¥—Ä—É–≥–∏—Ö —Ç–æ–∫–µ–Ω–æ–≤ –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –ª–æ–≥–∏–∫—É
            // –ü–æ–∫–∞ –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ —Å—É–º–º—ã —É–∂–µ –≤ USD
            return amount;
        }

        function formatMarketCap(value) {
            if (value >= 1000000000) {
                return `$${(value / 1000000000).toFixed(2)}B`;
            } else if (value >= 1000000) {
                return `$${(value / 1000000).toFixed(2)}M`;
            } else if (value >= 1000) {
                return `$${(value / 1000).toFixed(2)}K`;
            } else {
                return `$${value.toFixed(2)}`;
            }
        }

        function formatCurrency(value) {
            if (value >= 1000000) {
                return `$${(value / 1000000).toFixed(2)}M`;
            } else if (value >= 1000) {
                return `$${(value / 1000).toFixed(1)}K`;
            } else {
                return `$${value.toFixed(0)}`;
            }
        }

        function getCurrentMilestoneConfig(marketCap) {
            for (const milestone of config.marketCapMilestones) {
                if (marketCap >= milestone.min && marketCap < milestone.max) {
                    return milestone;
                }
            }
            return config.marketCapMilestones[config.marketCapMilestones.length - 1];
        }

        function getNextMilestone(marketCap) {
            const milestoneConfig = getCurrentMilestoneConfig(marketCap);
            const currentStep = Math.floor(marketCap / milestoneConfig.step) * milestoneConfig.step;
            return currentStep + milestoneConfig.step;
        }

        function updateMilestoneProgress() {
            const milestone = getNextMilestone(currentMarketCap);
            const previousMilestone = milestone - getCurrentMilestoneConfig(currentMarketCap).step;
            const progress = ((currentMarketCap - previousMilestone) / (milestone - previousMilestone)) * 100;
            
            document.getElementById('milestoneText').textContent = formatMarketCap(milestone);
            document.getElementById('progressFill').style.width = `${Math.max(0, Math.min(100, progress))}%`;
            document.getElementById('progressText').textContent = 
                `${formatMarketCap(currentMarketCap)} / ${formatMarketCap(milestone)}`;
            
            nextMilestone = milestone;
        }

        function updateMonitorDisplay() {
            document.getElementById('solPrice').textContent = `$${solPrice.toFixed(0)}`;
            document.getElementById('minBuyUSD').textContent = formatCurrency(config.buyThresholds.minBuyUSD);
            document.getElementById('lastCheck').textContent = new Date().toLocaleTimeString('ru-RU', {
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ –ø–æ–∫—É–ø–∫–∏ –ø–æ —Å—É–º–º–µ –≤ USD
        function getBuyType(usdAmount) {
            if (usdAmount >= config.buyThresholds.whaleBuyUSD) {
                return 'whale';
            } else if (usdAmount >= config.buyThresholds.bigBuyUSD) {
                return 'bigBuy';
            } else if (usdAmount >= config.buyThresholds.minBuyUSD) {
                return 'regular';
            }
            return null; // –ù–µ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
        }

        async function checkForMilestone(newMarketCap, oldMarketCap) {
            const oldMilestone = getNextMilestone(oldMarketCap);
            const newMilestone = getNextMilestone(newMarketCap);
            
            if (newMarketCap >= oldMilestone && oldMarketCap < oldMilestone) {
                console.log(`üéØ Milestone reached: ${formatMarketCap(oldMilestone)}`);
                await showMilestoneNotification(formatMarketCap(oldMilestone));
                setTimeout(() => spinRoulette('milestone'), 3500);
            }
        }

        async function showMilestoneNotification(amount) {
            if (isAnimating) return;
            isAnimating = true;
            
            const notification = document.getElementById('transactionNotification');
            document.getElementById('transactionAmount').textContent = amount;
            document.getElementById('transactionText').textContent = 'MILESTONE REACHED!';
            document.getElementById('transactionUser').textContent = `Market Cap: ${amount}`;
            document.getElementById('transactionDetails').textContent = 'Congratulations! üéâ';
            
            notification.classList.add('milestone', 'show');
            
            return new Promise(resolve => {
                setTimeout(() => {
                    notification.classList.remove('show', 'milestone');
                    setTimeout(() => {
                        isAnimating = false;
                        resolve();
                    }, 500);
                }, config.uiSettings?.notificationDuration || 3000);
            });
        }

        async function showBuyNotification(usdAmount, tokenAmount = null, tokenSymbol = 'SOL', userAddress = null) {
            if (isAnimating) return;
            isAnimating = true;
            
            const buyType = getBuyType(usdAmount);
            if (!buyType) return;

            const notification = document.getElementById('transactionNotification');
            
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
            let notificationText = '';
            let notificationClass = 'big-buy';
            
            if (buyType === 'whale') {
                notificationText = 'üêã WHALE DETECTED!';
                notificationClass = 'big-buy whale';
            } else if (buyType === 'bigBuy') {
                notificationText = 'üí∞ BIG BUY DETECTED!';
                notificationClass = 'big-buy';
            } else {
                notificationText = 'üöÄ BUY DETECTED!';
                notificationClass = 'big-buy';
            }
            
            document.getElementById('transactionAmount').textContent = formatCurrency(usdAmount);
            document.getElementById('transactionText').textContent = notificationText;
            document.getElementById('transactionUser').textContent = userAddress ? `User: ${userAddress}` : 'New Purchase';
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–µ—Ç–∞–ª–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
            let details = '';
            if (tokenAmount && tokenSymbol) {
                details = `${tokenAmount.toFixed(2)} ${tokenSymbol} ‚Ä¢ `;
            }
            details += 'Time for a challenge...';
            document.getElementById('transactionDetails').textContent = details;
            
            notification.className = `transaction-notification ${notificationClass} show`;
            
            return new Promise(resolve => {
                setTimeout(() => {
                    notification.classList.remove('show', 'big-buy', 'whale');
                    setTimeout(() => {
                        isAnimating = false;
                        resolve();
                    }, 500);
                }, config.uiSettings?.notificationDuration || 3000);
            });
        }

        // –°–∏–º—É–ª—è—Ü–∏—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
        async function startTransactionMonitoring() {
            if (!config.monitoringSettings.enableTransactionMonitoring) return;
            
            transactionMonitorActive = true;
            console.log('üîç Transaction monitoring started');
            
            setInterval(async () => {
                if (isAnimating) return;
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–µ–Ω—É SOL –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏
                await fetchSOLPrice();
                updateMonitorDisplay();
                
                // –°–∏–º—É–ª—è—Ü–∏—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ (–≤ —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –∑–¥–µ—Å—å –±—ã–ª –±—ã WebSocket Solana)
                if (Math.random() < 0.1) { // 10% —à–∞–Ω—Å —Å–∏–º—É–ª—è—Ü–∏–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
                    const mockTransaction = generateMockTransaction();
                    await processTransaction(mockTransaction);
                }
                
                statusElement.className = 'status monitoring';
                statusElement.textContent = 'üü° Monitoring transactions...';
                
            }, config.monitoringSettings.transactionCheckInterval || 10000);
        }

        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –º–æ–∫-—Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        function generateMockTransaction() {
            const amounts = [150, 250, 500, 1000, 2500, 5000, 10000, 25000];
            const usdAmount = amounts[Math.floor(Math.random() * amounts.length)];
            const solAmount = usdAmount / solPrice;
            
            return {
                usdAmount,
                tokenAmount: solAmount,
                tokenSymbol: 'SOL',
                userAddress: generateRandomAddress(),
                signature: generateRandomSignature()
            };
        }

        function generateRandomAddress() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz123456789';
            let result = '';
            for (let i = 0; i < 4; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            result += '...';
            for (let i = 0; i < 4; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        function generateRandomSignature() {
            return Math.random().toString(36).substring(7);
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        async function processTransaction(transaction) {
            const { usdAmount, tokenAmount, tokenSymbol, userAddress, signature } = transaction;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–ª–∏ –ª–∏ –º—ã —É–∂–µ —ç—Ç—É —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
            if (lastTransactions.has(signature)) return;
            lastTransactions.add(signature);
            
            // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ (—Ö—Ä–∞–Ω–∏–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 100)
            if (lastTransactions.size > 100) {
                const first = lastTransactions.values().next().value;
                lastTransactions.delete(first);
            }
            
            const buyType = getBuyType(usdAmount);
            if (!buyType) return;
            
            console.log(`üí∞ Buy detected: ${formatCurrency(usdAmount)} (${tokenAmount?.toFixed(2)} ${tokenSymbol})`);
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
            await showBuyNotification(usdAmount, tokenAmount, tokenSymbol, userAddress);
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º —Ä—É–ª–µ—Ç–∫—É –ø–æ—Å–ª–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
            setTimeout(() => spinRoulette(buyType), 3500);
        }

        async function startMonitoring() {
            const interval = config.monitoringSettings?.marketCapCheckInterval || 5000;
            
            // Start transaction monitoring if enabled
            if (config.monitoringSettings?.enableTransactionMonitoring) {
                await startTransactionMonitoring();
            }
            
            setInterval(async () => {
                if (isAnimating) return;
                
                const newMarketCap = await fetchMarketCap();
                if (newMarketCap > 0) {
                    marketCapElement.textContent = formatMarketCap(newMarketCap);
                    
                    // Check for milestones only if enabled
                    if (config.monitoringSettings?.enableMilestoneMonitoring !== false && currentMarketCap > 0) {
                        await checkForMilestone(newMarketCap, currentMarketCap);
                    }
                    
                    currentMarketCap = newMarketCap;
                    updateMilestoneProgress();
                    
                    if (!transactionMonitorActive) {
                        statusElement.className = 'status active';
                        statusElement.textContent = `üü¢ Monitoring ${getCurrentMilestoneConfig(newMarketCap).description || 'Active'}`;
                    }
                } else {
                    statusElement.className = 'status error';
                    statusElement.textContent = 'üî¥ API Error';
                }
            }, interval);
        }

        function getRandomTask(type = 'regular') {
            let availableTasks;
            
            switch(type) {
                case 'milestone':
                    availableTasks = specialTasks.milestone.length > 0 ? specialTasks.milestone : tasks;
                    break;
                case 'whale':
                    availableTasks = specialTasks.whale.length > 0 ? specialTasks.whale : specialTasks.bigBuy;
                    if (availableTasks.length === 0) availableTasks = tasks;
                    break;
                case 'bigBuy':
                    availableTasks = specialTasks.bigBuy.length > 0 ? specialTasks.bigBuy : tasks;
                    break;
                default:
                    availableTasks = specialTasks.regular.length > 0 ? specialTasks.regular : tasks;
            }
            
            return availableTasks[Math.floor(Math.random() * availableTasks.length)];
        }

        async function spinRoulette(taskType = 'regular') {
            if (isAnimating) return;
            isAnimating = true;
            
            rouletteContainer.classList.add('show');
            
            // Select task based on type
            const selectedTask = getRandomTask(taskType);
            
            // Random rotation (multiple full spins + random position)
            const randomSpin = 1440 + Math.random() * 1440; // 4-8 full rotations
            const selectedTaskIndex = Math.floor(Math.random() * 5); // Visual only
            const targetRotation = randomSpin + (selectedTaskIndex * 72); // 72 degrees per segment
            
            rouletteWheel.style.transform = `rotate(${targetRotation}deg)`;
            
            const duration = config.uiSettings?.rouletteDuration || 4000;
            const resultDuration = config.uiSettings?.taskResultDuration || 5000;
            
            setTimeout(() => {
                showTaskResult(selectedTask, taskType);
            }, duration);
            
            setTimeout(() => {
                rouletteContainer.classList.remove('show');
                setTimeout(() => {
                    rouletteWheel.style.transform = 'rotate(0deg)';
                    isAnimating = false;
                }, 800);
            }, duration + resultDuration);
        }

        function showTaskResult(task, type = 'regular') {
            let title;
            switch(type) {
                case 'milestone':
                    title = 'üéâ MILESTONE TASK!';
                    break;
                case 'whale':
                    title = 'üêã WHALE TASK!';
                    break;
                case 'bigBuy':
                    title = 'üí∞ BIG BUY TASK!';
                    break;
                default:
                    title = 'üéØ CHALLENGE SELECTED!';
            }
            
            document.getElementById('taskTitle').textContent = title;
            document.getElementById('taskDescription').textContent = task;
            taskResult.classList.add('show');
            
            const duration = config.uiSettings?.taskResultDuration || 5000;
            setTimeout(() => {
                taskResult.classList.remove('show');
            }, duration);
        }

        // Test functions
        async function testBuy(usdAmount = 500) {
            console.log(`Testing buy notification for ${usdAmount}`);
            const solAmount = usdAmount / solPrice;
            await showBuyNotification(usdAmount, solAmount, 'SOL', generateRandomAddress());
            setTimeout(() => {
                const buyType = getBuyType(usdAmount);
                spinRoulette(buyType || 'regular');
            }, 3500);
        }

        async function testMilestone(amount = '$50K') {
            console.log(`Testing milestone notification for ${amount}`);
            await showMilestoneNotification(amount);
            setTimeout(() => spinRoulette('milestone'), 3500);
        }

        function testRoulette(type = 'regular') {
            console.log(`Testing roulette with type: ${type}`);
            spinRoulette(type);
        }

        // Legacy function for compatibility
        async function testTransaction(usdAmount = 1000) {
            await testBuy(usdAmount);
        }

        // Load custom config if available
        async function loadConfig() {
            try {
                const response = await fetch('./config.json');
                if (!response.ok) throw new Error('Config not found');
                
                const customConfig = await response.json();
                
                // Merge configs deeply
                config = {
                    ...config,
                    ...customConfig,
                    buyThresholds: { ...config.buyThresholds, ...(customConfig.buyThresholds || {}) },
                    monitoringSettings: { ...config.monitoringSettings, ...(customConfig.monitoringSettings || {}) },
                    uiSettings: { ...config.uiSettings, ...(customConfig.uiSettings || {}) }
                };
                
                console.log('‚úÖ Custom config loaded:', config);
                updateMilestoneProgress(); // Refresh with new config
            } catch (error) {
                console.log('‚ö†Ô∏è Using default config - config.json not found or invalid');
            }
        }

        // Load custom tasks if available  
        async function loadTasks() {
            try {
                const response = await fetch('./tasks.json');
                if (!response.ok) throw new Error('Tasks not found');
                
                const tasksData = await response.json();
                
                // Load different task types
                if (tasksData.tasks) {
                    tasks = tasksData.tasks;
                    specialTasks.regular = tasksData.tasks;
                }
                
                if (tasksData.milestoneSpecialTasks) {
                    specialTasks.milestone = tasksData.milestoneSpecialTasks;
                }
                
                if (tasksData.bigBuyTasks) {
                    specialTasks.bigBuy = tasksData.bigBuyTasks;
                }

                if (tasksData.whaleTasks) {
                    specialTasks.whale = tasksData.whaleTasks;
                }
                
                updateTaskSegments();
                console.log('‚úÖ Custom tasks loaded');
                console.log(`- Regular tasks: ${specialTasks.regular.length}`);
                console.log(`- Milestone tasks: ${specialTasks.milestone.length}`);
                console.log(`- Big buy tasks: ${specialTasks.bigBuy.length}`);
                console.log(`- Whale tasks: ${specialTasks.whale.length}`);
                
            } catch (error) {
                console.log('‚ö†Ô∏è Using default tasks - tasks.json not found or invalid');
                specialTasks.regular = tasks;
            }
        }
    </script>
</body>
</html>
